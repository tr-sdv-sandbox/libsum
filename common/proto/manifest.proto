/**
 * @file manifest.proto
 * @brief Secure Update Manifest Protocol Buffer Schema
 *
 * Uptane-inspired security model for embedded systems:
 * - Delegation via certificate chains (Root → Intermediate → Update cert)
 * - Per-artifact rollback protection via security_version
 * - Metadata sequencing via manifest_version
 * - Snapshot protection via manifest_hash
 * - Prerequisites for safe migrations (partition layout, schema changes)
 * - Explicit artifact removal (safe-by-default)
 * - FULL vs DELTA manifest support
 * - Flexible artifact routing via type and target_ecu
 * - Deterministic installation order
 * - Content-addressable storage support
 * - Mandatory per-device encryption
 *
 * Copyright 2025 libsum contributors
 * SPDX-License-Identifier: Apache-2.0
 */

syntax = "proto3";

package sum.proto;

/**
 * Secure Update Manifest
 *
 * This message is embedded in X.509 certificate extension (OID 1.3.6.1.3.2).
 * The certificate provides cryptographic chain-of-trust via PKI.
 */
/**
 * Semantic version (major.minor.patch)
 *
 * Used for compatibility checking:
 * - Major: Incompatible API changes
 * - Minor: Backward-compatible functionality additions
 * - Patch: Backward-compatible bug fixes
 */
message SemVer {
  uint32 major = 1;
  uint32 minor = 2;
  uint32 patch = 3;
  string prerelease = 4;  // Optional: "alpha", "beta.1", "rc.2"
  string build_metadata = 5;  // Optional: "20250124", "git.abc123"
}

/**
 * Manifest type (FULL vs DELTA update)
 */
enum ManifestType {
  // Complete system state - all artifacts device should have
  FULL = 0;

  // Partial update - only changed artifacts + optional removals
  // Artifacts not mentioned are preserved (safe-by-default)
  DELTA = 1;
}

message Manifest {
  // Schema version (for protocol evolution)
  // Used when protobuf format itself changes
  uint32 version = 1;

  // Metadata sequence number (GLOBAL monotonic, MUST increment)
  // Tracks when manifest was issued (Uptane/TUF "version" field)
  // Used for:
  //   - Ordering manifests (workshop knows which to apply first)
  //   - Replay attack prevention (cannot reuse old manifests)
  //   - Metadata freshness (always increases, even for A/B variants)
  // Example: 1 → 2 → 3 → 4 (never decreases, never repeats)
  uint64 manifest_version = 2;

  // Manifest type (FULL or DELTA)
  ManifestType type = 5;

  // Prerequisites (all must be satisfied to install this manifest)
  // Used for migration safety (e.g., partition layout, schema migrations)
  // Manifest is rejected if any prerequisite fails
  repeated Prerequisite prerequisites = 6;

  // SHA-256 hash of canonical manifest serialization (excluding signature field)
  // Prevents mix-and-match attacks (Uptane Snapshot role)
  bytes manifest_hash = 4;

  // Software artifacts to install/update
  repeated Artifact artifacts = 10;

  // Artifacts to explicitly remove (DELTA manifests only)
  // Must uniquely identify artifact by (name, type, target_ecu)
  // Default: Keep all artifacts not mentioned (safe-by-default)
  repeated ArtifactIdentifier remove_artifacts = 11;

  // Encryption parameters (AES-GCM + X25519 key wrapping)
  // SECURITY: One entry per (artifact, device) pair - mandatory per-device encryption
  repeated EncryptionParams encryption = 12;

  // Ed25519 signature over canonical manifest (excluding this field)
  // Signed by the private key corresponding to the certificate's public key
  bytes signature = 20;

  // DER-encoded signing certificate (typically intermediate CA)
  // Used for signature verification on artifacts
  bytes signing_cert = 21;

  // Optional user metadata (e.g., vendor, release notes, campaign_id, etc.)
  map<string, string> metadata = 30;

  // REMOVED: release_counter (now per-artifact as security_version)
  // REMOVED: software_version (now per-artifact as version)
}

/**
 * Prerequisite for installing a manifest
 * Ensures device is at correct state before complex migrations
 * (e.g., partition layout changes, database schema migrations, Android upgrades)
 */
message Prerequisite {
  // Artifact that must exist with minimum version
  string artifact_name = 1;

  // Minimum security version required
  // Device rejects manifest if current artifact has lower security_version
  uint64 min_security_version = 2;

  // Optional: Minimum feature version (SemVer)
  // Device rejects manifest if current artifact version is lower
  SemVer min_version = 3;

  // Human-readable reason (for diagnostics/logging)
  // Example: "Android 13 requires Android 12 partition layout"
  string reason = 4;
}

/**
 * Uniquely identifies an artifact for removal
 * Combination of (name, type, target_ecu) forms unique key
 */
message ArtifactIdentifier {
  // Artifact name (required)
  string name = 1;

  // Artifact type (required)
  // Examples: "firmware", "bootloader", "filesystem", "container"
  string type = 2;

  // Target ECU (required)
  // Examples: "primary", "wifi-coprocessor", "camera"
  string target_ecu = 3;
}

/**
 * Download source with priority-based fallback
 */
message Source {
  // URI to fetch artifact
  // Supported schemes: http://, https://, s3://, ipfs://, file://, ca://
  string uri = 1;

  // Priority (0 = highest, try first; 1 = fallback; etc.)
  uint32 priority = 2;

  // Optional hint about source type for client optimization
  // Examples: "http", "s3", "ipfs", "file", "ca"
  string type = 3;
}

/**
 * Software artifact (firmware, filesystem, container, etc.)
 *
 * Uptane-inspired fields:
 * - type: Identifies artifact purpose (similar to Uptane custom metadata)
 * - target_ecu: Routes to specific component (Uptane ecuIdentifier)
 * - install_order: Deterministic installation sequence
 * - security_version: Rollback protection (Uptane releaseCounter)
 */
message Artifact {
  // Unique identifier within this manifest
  // Examples: "application", "bootloader", "filesystem"
  string name = 1;

  // Artifact type (determines handling on device)
  // Standard types: "firmware", "bootloader", "filesystem", "container", "package", "map", "model", "data"
  // Custom types allowed (e.g., "my-company-config")
  string type = 2;

  // Target component/ECU identifier (Uptane ecuIdentifier)
  // Examples: "primary", "wifi-coprocessor", "camera", "lidar"
  // Device routes artifact to appropriate component based on this field
  string target_ecu = 3;

  // Installation order (0 = first, 1 = second, etc.)
  // Device MUST process artifacts in ascending order
  // Use case: Install bootloader (order=0) before firmware (order=1)
  uint32 install_order = 4;

  // === Versioning ===

  // Feature version (semantic, can skip/go backwards)
  // Used for compatibility checking and display
  // Example: 2.0.0 → 2.1.0-beta → 2.0.0 (A/B test revert)
  SemVer version = 50;

  // Security version (MONOTONIC per artifact, MUST increment on security changes)
  // Used for:
  //   - Rollback protection (cannot install older security versions)
  //   - CVE constraint enforcement (external CVE broadcast sets minimum)
  //   - A/B testing support (multiple feature versions can share same security_version)
  // Example: 100 → 100 (A/B variant, same security) → 101 (CVE fix)
  // Corresponds to Uptane's releaseCounter per image
  uint64 security_version = 51;

  // === Plaintext verification (after decryption) ===

  // Hash algorithm for plaintext (currently only "SHA-256" supported)
  string hash_algorithm = 10;

  // Expected hash of decrypted artifact (32 bytes for SHA-256)
  // This is what gets signed by signature field
  bytes expected_hash = 11;

  // Size of plaintext in bytes (for storage planning)
  uint64 size = 12;

  // === Ciphertext verification (for download) ===

  // SHA-256 hash of encrypted file (*.enc)
  // Used for:
  // 1. Content-addressable storage (ipfs://<ciphertext_hash>)
  // 2. Verify download integrity before decryption
  // 3. Detect corrupted/wrong downloads early
  bytes ciphertext_hash = 13;

  // Size of encrypted file in bytes (for download progress)
  uint64 ciphertext_size = 14;

  // === Signature ===

  // Signature algorithm (currently only "Ed25519" supported)
  string signature_algorithm = 20;

  // Ed25519 signature over expected_hash (64 bytes)
  // Signed by signing_cert's private key
  bytes signature = 21;

  // === Source discovery ===

  // Download sources (try in priority order)
  // Source type determines fetch method:
  //   - "http"/"https": Fetch from source.uri
  //   - "ipfs": Use ciphertext_hash as IPFS CID
  //   - "ca": Lookup in local cache by ciphertext_hash
  //   - "bittorrent": Use ciphertext_hash as infohash
  // ciphertext_hash always used for verification after download
  repeated Source sources = 40;
}

/**
 * Encryption parameters for artifact
 *
 * Uses AES-128-GCM AEAD for authenticated encryption
 * Uses X25519 ECDH + HKDF + ChaCha20-Poly1305 for key wrapping
 *
 * SECURITY: device_id is MANDATORY for per-device encryption
 * Each device can only decrypt artifacts encrypted specifically for it
 */
message EncryptionParams {
  // Which artifact this applies to (matches Artifact.name)
  string artifact_name = 1;

  // MANDATORY: Target device identifier
  // Backend MUST lookup device's public key and wrap key specifically for that device
  // Device MUST verify this matches its own ID before attempting unwrap
  // SECURITY: Prevents compromise of one device from affecting others
  string device_id = 2;

  // === AES-GCM parameters ===

  // Encryption algorithm (currently only "AES-128-GCM" supported)
  string algorithm = 10;

  // GCM nonce/IV (12 bytes)
  // Stored in manifest, NOT in encrypted file
  bytes iv = 11;

  // GCM authentication tag (16 bytes)
  // Stored in manifest, NOT in encrypted file
  // Verified during decryption finalization
  bytes tag = 12;

  // === Key wrapping (X25519) ===

  // Key wrapping algorithm (currently only "X25519-HKDF-SHA256-ChaCha20Poly1305" supported)
  string key_wrapping_algorithm = 20;

  // Wrapped AES-128 key (76 bytes)
  // Format: ephemeral_pubkey(32) || nonce(12) || ciphertext(16) || auth_tag(16)
  // Device unwraps using its X25519 private key
  bytes wrapped_key = 21;
}

/**
 * Artifact information (what an update provides)
 * Duplicates key fields from Artifact for unverified filtering
 */
message ArtifactInfo {
  // Unique identifier
  string name = 1;

  // Artifact type
  string type = 2;

  // Target ECU
  string target_ecu = 3;

  // Security version this update provides
  uint64 security_version = 4;

  // Feature version (optional, for display)
  SemVer version = 5;
}

/**
 * Artifact constraint (what an update requires from device)
 * Used by workshop to determine safe upgrade path
 */
message ArtifactConstraint {
  // Artifact identifier
  string name = 1;
  string type = 2;
  string target_ecu = 3;

  // Minimum security version required on device (inclusive)
  // Device must have artifact with security_version >= this value
  uint64 min_security_version = 4;

  // Maximum security version supported (inclusive, optional)
  // If set, device must have artifact with security_version <= this value
  // Used for limiting upgrade jumps (e.g., database migrations)
  // If 0, no upper limit
  uint64 max_security_version = 5;
}

/**
 * Device metadata (embedded in X.509 certificate extension OID 1.3.6.1.3.1)
 *
 * Identifies the device/certificate purpose and hardware requirements.
 * Used for certificate validation and update routing.
 *
 * SECURITY: This data is UNVERIFIED (readable without signature check).
 * Used for filtering and operational decisions only.
 * Device MUST use verified manifest data for security decisions.
 */
message DeviceMetadata {
  // Device type/role
  // Examples: "Root-CA", "Intermediate-CA", "ESP32-OTA-Example", "Production-Device"
  string device_type = 1;

  // Unique hardware identifier
  // Examples: "LIBSUM-TINY-ROOT-CA", "ESP32-TEST-DEVICE-001", device serial number
  string hardware_id = 2;

  // Manufacturer/vendor name
  string manufacturer = 3;

  // Optional hardware version
  // Examples: "v1.0", "rev-B", "2024"
  string hardware_version = 4;

  // === Operational metadata (for workshop/filtering) ===

  // Manifest version (for ordering updates)
  // Workshop uses this to sort updates in application sequence
  // Device MUST use verified manifest.manifest_version for replay protection
  uint64 manifest_version = 5;

  // Manifest type (FULL or DELTA)
  // Workshop uses this to determine if device state must be known
  ManifestType manifest_type = 6;

  // What this update provides (artifacts in manifest)
  // Workshop uses this to see what will be installed
  repeated ArtifactInfo provides = 7;

  // What this update requires from device
  // Workshop uses this to determine safe upgrade path
  // Example: Update requires firmware v5-12, device at v10 → safe
  //          Update requires firmware v15+, device at v10 → must upgrade first
  repeated ArtifactConstraint requires = 8;
}
