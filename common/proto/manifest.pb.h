// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: manifest.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_manifest_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_manifest_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_manifest_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_manifest_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_manifest_2eproto;
namespace sum {
namespace proto {
class Artifact;
struct ArtifactDefaultTypeInternal;
extern ArtifactDefaultTypeInternal _Artifact_default_instance_;
class DeviceMetadata;
struct DeviceMetadataDefaultTypeInternal;
extern DeviceMetadataDefaultTypeInternal _DeviceMetadata_default_instance_;
class EncryptionParams;
struct EncryptionParamsDefaultTypeInternal;
extern EncryptionParamsDefaultTypeInternal _EncryptionParams_default_instance_;
class Manifest;
struct ManifestDefaultTypeInternal;
extern ManifestDefaultTypeInternal _Manifest_default_instance_;
class Manifest_MetadataEntry_DoNotUse;
struct Manifest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern Manifest_MetadataEntry_DoNotUseDefaultTypeInternal _Manifest_MetadataEntry_DoNotUse_default_instance_;
class Source;
struct SourceDefaultTypeInternal;
extern SourceDefaultTypeInternal _Source_default_instance_;
}  // namespace proto
}  // namespace sum
PROTOBUF_NAMESPACE_OPEN
template<> ::sum::proto::Artifact* Arena::CreateMaybeMessage<::sum::proto::Artifact>(Arena*);
template<> ::sum::proto::DeviceMetadata* Arena::CreateMaybeMessage<::sum::proto::DeviceMetadata>(Arena*);
template<> ::sum::proto::EncryptionParams* Arena::CreateMaybeMessage<::sum::proto::EncryptionParams>(Arena*);
template<> ::sum::proto::Manifest* Arena::CreateMaybeMessage<::sum::proto::Manifest>(Arena*);
template<> ::sum::proto::Manifest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::sum::proto::Manifest_MetadataEntry_DoNotUse>(Arena*);
template<> ::sum::proto::Source* Arena::CreateMaybeMessage<::sum::proto::Source>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sum {
namespace proto {

// ===================================================================

class Manifest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Manifest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Manifest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Manifest_MetadataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Manifest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Manifest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Manifest_MetadataEntry_DoNotUse& other);
  static const Manifest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Manifest_MetadataEntry_DoNotUse*>(&_Manifest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sum.proto.Manifest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sum.proto.Manifest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_manifest_2eproto;
};

// -------------------------------------------------------------------

class Manifest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sum.proto.Manifest) */ {
 public:
  inline Manifest() : Manifest(nullptr) {}
  ~Manifest() override;
  explicit PROTOBUF_CONSTEXPR Manifest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Manifest(const Manifest& from);
  Manifest(Manifest&& from) noexcept
    : Manifest() {
    *this = ::std::move(from);
  }

  inline Manifest& operator=(const Manifest& from) {
    CopyFrom(from);
    return *this;
  }
  inline Manifest& operator=(Manifest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Manifest& default_instance() {
    return *internal_default_instance();
  }
  static inline const Manifest* internal_default_instance() {
    return reinterpret_cast<const Manifest*>(
               &_Manifest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Manifest& a, Manifest& b) {
    a.Swap(&b);
  }
  inline void Swap(Manifest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Manifest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Manifest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Manifest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Manifest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Manifest& from) {
    Manifest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Manifest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sum.proto.Manifest";
  }
  protected:
  explicit Manifest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArtifactsFieldNumber = 10,
    kEncryptionFieldNumber = 11,
    kMetadataFieldNumber = 30,
    kManifestHashFieldNumber = 4,
    kSignatureFieldNumber = 20,
    kSigningCertFieldNumber = 21,
    kManifestVersionFieldNumber = 2,
    kReleaseCounterFieldNumber = 3,
    kVersionFieldNumber = 1,
  };
  // repeated .sum.proto.Artifact artifacts = 10;
  int artifacts_size() const;
  private:
  int _internal_artifacts_size() const;
  public:
  void clear_artifacts();
  ::sum::proto::Artifact* mutable_artifacts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sum::proto::Artifact >*
      mutable_artifacts();
  private:
  const ::sum::proto::Artifact& _internal_artifacts(int index) const;
  ::sum::proto::Artifact* _internal_add_artifacts();
  public:
  const ::sum::proto::Artifact& artifacts(int index) const;
  ::sum::proto::Artifact* add_artifacts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sum::proto::Artifact >&
      artifacts() const;

  // repeated .sum.proto.EncryptionParams encryption = 11;
  int encryption_size() const;
  private:
  int _internal_encryption_size() const;
  public:
  void clear_encryption();
  ::sum::proto::EncryptionParams* mutable_encryption(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sum::proto::EncryptionParams >*
      mutable_encryption();
  private:
  const ::sum::proto::EncryptionParams& _internal_encryption(int index) const;
  ::sum::proto::EncryptionParams* _internal_add_encryption();
  public:
  const ::sum::proto::EncryptionParams& encryption(int index) const;
  ::sum::proto::EncryptionParams* add_encryption();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sum::proto::EncryptionParams >&
      encryption() const;

  // map<string, string> metadata = 30;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // bytes manifest_hash = 4;
  void clear_manifest_hash();
  const std::string& manifest_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manifest_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manifest_hash();
  PROTOBUF_NODISCARD std::string* release_manifest_hash();
  void set_allocated_manifest_hash(std::string* manifest_hash);
  private:
  const std::string& _internal_manifest_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manifest_hash(const std::string& value);
  std::string* _internal_mutable_manifest_hash();
  public:

  // bytes signature = 20;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // bytes signing_cert = 21;
  void clear_signing_cert();
  const std::string& signing_cert() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signing_cert(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signing_cert();
  PROTOBUF_NODISCARD std::string* release_signing_cert();
  void set_allocated_signing_cert(std::string* signing_cert);
  private:
  const std::string& _internal_signing_cert() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signing_cert(const std::string& value);
  std::string* _internal_mutable_signing_cert();
  public:

  // uint64 manifest_version = 2;
  void clear_manifest_version();
  uint64_t manifest_version() const;
  void set_manifest_version(uint64_t value);
  private:
  uint64_t _internal_manifest_version() const;
  void _internal_set_manifest_version(uint64_t value);
  public:

  // uint64 release_counter = 3;
  void clear_release_counter();
  uint64_t release_counter() const;
  void set_release_counter(uint64_t value);
  private:
  uint64_t _internal_release_counter() const;
  void _internal_set_release_counter(uint64_t value);
  public:

  // uint32 version = 1;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sum.proto.Manifest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sum::proto::Artifact > artifacts_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sum::proto::EncryptionParams > encryption_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Manifest_MetadataEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manifest_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signing_cert_;
    uint64_t manifest_version_;
    uint64_t release_counter_;
    uint32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_manifest_2eproto;
};
// -------------------------------------------------------------------

class Source final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sum.proto.Source) */ {
 public:
  inline Source() : Source(nullptr) {}
  ~Source() override;
  explicit PROTOBUF_CONSTEXPR Source(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Source(const Source& from);
  Source(Source&& from) noexcept
    : Source() {
    *this = ::std::move(from);
  }

  inline Source& operator=(const Source& from) {
    CopyFrom(from);
    return *this;
  }
  inline Source& operator=(Source&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Source& default_instance() {
    return *internal_default_instance();
  }
  static inline const Source* internal_default_instance() {
    return reinterpret_cast<const Source*>(
               &_Source_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Source& a, Source& b) {
    a.Swap(&b);
  }
  inline void Swap(Source* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Source* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Source* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Source>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Source& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Source& from) {
    Source::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Source* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sum.proto.Source";
  }
  protected:
  explicit Source(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kTypeFieldNumber = 3,
    kPriorityFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string type = 3;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // uint32 priority = 2;
  void clear_priority();
  uint32_t priority() const;
  void set_priority(uint32_t value);
  private:
  uint32_t _internal_priority() const;
  void _internal_set_priority(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sum.proto.Source)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    uint32_t priority_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_manifest_2eproto;
};
// -------------------------------------------------------------------

class Artifact final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sum.proto.Artifact) */ {
 public:
  inline Artifact() : Artifact(nullptr) {}
  ~Artifact() override;
  explicit PROTOBUF_CONSTEXPR Artifact(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Artifact(const Artifact& from);
  Artifact(Artifact&& from) noexcept
    : Artifact() {
    *this = ::std::move(from);
  }

  inline Artifact& operator=(const Artifact& from) {
    CopyFrom(from);
    return *this;
  }
  inline Artifact& operator=(Artifact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Artifact& default_instance() {
    return *internal_default_instance();
  }
  static inline const Artifact* internal_default_instance() {
    return reinterpret_cast<const Artifact*>(
               &_Artifact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Artifact& a, Artifact& b) {
    a.Swap(&b);
  }
  inline void Swap(Artifact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Artifact* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Artifact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Artifact>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Artifact& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Artifact& from) {
    Artifact::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Artifact* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sum.proto.Artifact";
  }
  protected:
  explicit Artifact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcesFieldNumber = 40,
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kTargetEcuFieldNumber = 3,
    kHashAlgorithmFieldNumber = 10,
    kExpectedHashFieldNumber = 11,
    kCiphertextHashFieldNumber = 13,
    kSignatureAlgorithmFieldNumber = 20,
    kSignatureFieldNumber = 21,
    kSizeFieldNumber = 12,
    kCiphertextSizeFieldNumber = 14,
    kInstallOrderFieldNumber = 4,
    kContentAddressableFieldNumber = 41,
  };
  // repeated .sum.proto.Source sources = 40;
  int sources_size() const;
  private:
  int _internal_sources_size() const;
  public:
  void clear_sources();
  ::sum::proto::Source* mutable_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sum::proto::Source >*
      mutable_sources();
  private:
  const ::sum::proto::Source& _internal_sources(int index) const;
  ::sum::proto::Source* _internal_add_sources();
  public:
  const ::sum::proto::Source& sources(int index) const;
  ::sum::proto::Source* add_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sum::proto::Source >&
      sources() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string target_ecu = 3;
  void clear_target_ecu();
  const std::string& target_ecu() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_ecu(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_ecu();
  PROTOBUF_NODISCARD std::string* release_target_ecu();
  void set_allocated_target_ecu(std::string* target_ecu);
  private:
  const std::string& _internal_target_ecu() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_ecu(const std::string& value);
  std::string* _internal_mutable_target_ecu();
  public:

  // string hash_algorithm = 10;
  void clear_hash_algorithm();
  const std::string& hash_algorithm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash_algorithm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash_algorithm();
  PROTOBUF_NODISCARD std::string* release_hash_algorithm();
  void set_allocated_hash_algorithm(std::string* hash_algorithm);
  private:
  const std::string& _internal_hash_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash_algorithm(const std::string& value);
  std::string* _internal_mutable_hash_algorithm();
  public:

  // bytes expected_hash = 11;
  void clear_expected_hash();
  const std::string& expected_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expected_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expected_hash();
  PROTOBUF_NODISCARD std::string* release_expected_hash();
  void set_allocated_expected_hash(std::string* expected_hash);
  private:
  const std::string& _internal_expected_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expected_hash(const std::string& value);
  std::string* _internal_mutable_expected_hash();
  public:

  // bytes ciphertext_hash = 13;
  void clear_ciphertext_hash();
  const std::string& ciphertext_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ciphertext_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ciphertext_hash();
  PROTOBUF_NODISCARD std::string* release_ciphertext_hash();
  void set_allocated_ciphertext_hash(std::string* ciphertext_hash);
  private:
  const std::string& _internal_ciphertext_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ciphertext_hash(const std::string& value);
  std::string* _internal_mutable_ciphertext_hash();
  public:

  // string signature_algorithm = 20;
  void clear_signature_algorithm();
  const std::string& signature_algorithm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature_algorithm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature_algorithm();
  PROTOBUF_NODISCARD std::string* release_signature_algorithm();
  void set_allocated_signature_algorithm(std::string* signature_algorithm);
  private:
  const std::string& _internal_signature_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature_algorithm(const std::string& value);
  std::string* _internal_mutable_signature_algorithm();
  public:

  // bytes signature = 21;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // uint64 size = 12;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // uint64 ciphertext_size = 14;
  void clear_ciphertext_size();
  uint64_t ciphertext_size() const;
  void set_ciphertext_size(uint64_t value);
  private:
  uint64_t _internal_ciphertext_size() const;
  void _internal_set_ciphertext_size(uint64_t value);
  public:

  // uint32 install_order = 4;
  void clear_install_order();
  uint32_t install_order() const;
  void set_install_order(uint32_t value);
  private:
  uint32_t _internal_install_order() const;
  void _internal_set_install_order(uint32_t value);
  public:

  // bool content_addressable = 41;
  void clear_content_addressable();
  bool content_addressable() const;
  void set_content_addressable(bool value);
  private:
  bool _internal_content_addressable() const;
  void _internal_set_content_addressable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sum.proto.Artifact)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sum::proto::Source > sources_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_ecu_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_algorithm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expected_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ciphertext_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_algorithm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    uint64_t size_;
    uint64_t ciphertext_size_;
    uint32_t install_order_;
    bool content_addressable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_manifest_2eproto;
};
// -------------------------------------------------------------------

class EncryptionParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sum.proto.EncryptionParams) */ {
 public:
  inline EncryptionParams() : EncryptionParams(nullptr) {}
  ~EncryptionParams() override;
  explicit PROTOBUF_CONSTEXPR EncryptionParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EncryptionParams(const EncryptionParams& from);
  EncryptionParams(EncryptionParams&& from) noexcept
    : EncryptionParams() {
    *this = ::std::move(from);
  }

  inline EncryptionParams& operator=(const EncryptionParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncryptionParams& operator=(EncryptionParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncryptionParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const EncryptionParams* internal_default_instance() {
    return reinterpret_cast<const EncryptionParams*>(
               &_EncryptionParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EncryptionParams& a, EncryptionParams& b) {
    a.Swap(&b);
  }
  inline void Swap(EncryptionParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncryptionParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncryptionParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EncryptionParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EncryptionParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EncryptionParams& from) {
    EncryptionParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EncryptionParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sum.proto.EncryptionParams";
  }
  protected:
  explicit EncryptionParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactNameFieldNumber = 1,
    kDeviceIdFieldNumber = 2,
    kAlgorithmFieldNumber = 10,
    kIvFieldNumber = 11,
    kTagFieldNumber = 12,
    kKeyWrappingAlgorithmFieldNumber = 20,
    kWrappedKeyFieldNumber = 21,
  };
  // string artifact_name = 1;
  void clear_artifact_name();
  const std::string& artifact_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artifact_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artifact_name();
  PROTOBUF_NODISCARD std::string* release_artifact_name();
  void set_allocated_artifact_name(std::string* artifact_name);
  private:
  const std::string& _internal_artifact_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artifact_name(const std::string& value);
  std::string* _internal_mutable_artifact_name();
  public:

  // string device_id = 2;
  void clear_device_id();
  const std::string& device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);
  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(const std::string& value);
  std::string* _internal_mutable_device_id();
  public:

  // string algorithm = 10;
  void clear_algorithm();
  const std::string& algorithm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_algorithm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_algorithm();
  PROTOBUF_NODISCARD std::string* release_algorithm();
  void set_allocated_algorithm(std::string* algorithm);
  private:
  const std::string& _internal_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_algorithm(const std::string& value);
  std::string* _internal_mutable_algorithm();
  public:

  // bytes iv = 11;
  void clear_iv();
  const std::string& iv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iv();
  PROTOBUF_NODISCARD std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  private:
  const std::string& _internal_iv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // bytes tag = 12;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // string key_wrapping_algorithm = 20;
  void clear_key_wrapping_algorithm();
  const std::string& key_wrapping_algorithm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_wrapping_algorithm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_wrapping_algorithm();
  PROTOBUF_NODISCARD std::string* release_key_wrapping_algorithm();
  void set_allocated_key_wrapping_algorithm(std::string* key_wrapping_algorithm);
  private:
  const std::string& _internal_key_wrapping_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_wrapping_algorithm(const std::string& value);
  std::string* _internal_mutable_key_wrapping_algorithm();
  public:

  // bytes wrapped_key = 21;
  void clear_wrapped_key();
  const std::string& wrapped_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wrapped_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wrapped_key();
  PROTOBUF_NODISCARD std::string* release_wrapped_key();
  void set_allocated_wrapped_key(std::string* wrapped_key);
  private:
  const std::string& _internal_wrapped_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wrapped_key(const std::string& value);
  std::string* _internal_mutable_wrapped_key();
  public:

  // @@protoc_insertion_point(class_scope:sum.proto.EncryptionParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr algorithm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_wrapping_algorithm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wrapped_key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_manifest_2eproto;
};
// -------------------------------------------------------------------

class DeviceMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sum.proto.DeviceMetadata) */ {
 public:
  inline DeviceMetadata() : DeviceMetadata(nullptr) {}
  ~DeviceMetadata() override;
  explicit PROTOBUF_CONSTEXPR DeviceMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceMetadata(const DeviceMetadata& from);
  DeviceMetadata(DeviceMetadata&& from) noexcept
    : DeviceMetadata() {
    *this = ::std::move(from);
  }

  inline DeviceMetadata& operator=(const DeviceMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceMetadata& operator=(DeviceMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceMetadata* internal_default_instance() {
    return reinterpret_cast<const DeviceMetadata*>(
               &_DeviceMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeviceMetadata& a, DeviceMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceMetadata& from) {
    DeviceMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sum.proto.DeviceMetadata";
  }
  protected:
  explicit DeviceMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceTypeFieldNumber = 1,
    kHardwareIdFieldNumber = 2,
    kManufacturerFieldNumber = 3,
    kHardwareVersionFieldNumber = 4,
  };
  // string device_type = 1;
  void clear_device_type();
  const std::string& device_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_type();
  PROTOBUF_NODISCARD std::string* release_device_type();
  void set_allocated_device_type(std::string* device_type);
  private:
  const std::string& _internal_device_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_type(const std::string& value);
  std::string* _internal_mutable_device_type();
  public:

  // string hardware_id = 2;
  void clear_hardware_id();
  const std::string& hardware_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hardware_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hardware_id();
  PROTOBUF_NODISCARD std::string* release_hardware_id();
  void set_allocated_hardware_id(std::string* hardware_id);
  private:
  const std::string& _internal_hardware_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hardware_id(const std::string& value);
  std::string* _internal_mutable_hardware_id();
  public:

  // string manufacturer = 3;
  void clear_manufacturer();
  const std::string& manufacturer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manufacturer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manufacturer();
  PROTOBUF_NODISCARD std::string* release_manufacturer();
  void set_allocated_manufacturer(std::string* manufacturer);
  private:
  const std::string& _internal_manufacturer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacturer(const std::string& value);
  std::string* _internal_mutable_manufacturer();
  public:

  // string hardware_version = 4;
  void clear_hardware_version();
  const std::string& hardware_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hardware_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hardware_version();
  PROTOBUF_NODISCARD std::string* release_hardware_version();
  void set_allocated_hardware_version(std::string* hardware_version);
  private:
  const std::string& _internal_hardware_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hardware_version(const std::string& value);
  std::string* _internal_mutable_hardware_version();
  public:

  // @@protoc_insertion_point(class_scope:sum.proto.DeviceMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hardware_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hardware_version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_manifest_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Manifest

// uint32 version = 1;
inline void Manifest::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t Manifest::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t Manifest::version() const {
  // @@protoc_insertion_point(field_get:sum.proto.Manifest.version)
  return _internal_version();
}
inline void Manifest::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void Manifest::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:sum.proto.Manifest.version)
}

// uint64 manifest_version = 2;
inline void Manifest::clear_manifest_version() {
  _impl_.manifest_version_ = uint64_t{0u};
}
inline uint64_t Manifest::_internal_manifest_version() const {
  return _impl_.manifest_version_;
}
inline uint64_t Manifest::manifest_version() const {
  // @@protoc_insertion_point(field_get:sum.proto.Manifest.manifest_version)
  return _internal_manifest_version();
}
inline void Manifest::_internal_set_manifest_version(uint64_t value) {
  
  _impl_.manifest_version_ = value;
}
inline void Manifest::set_manifest_version(uint64_t value) {
  _internal_set_manifest_version(value);
  // @@protoc_insertion_point(field_set:sum.proto.Manifest.manifest_version)
}

// uint64 release_counter = 3;
inline void Manifest::clear_release_counter() {
  _impl_.release_counter_ = uint64_t{0u};
}
inline uint64_t Manifest::_internal_release_counter() const {
  return _impl_.release_counter_;
}
inline uint64_t Manifest::release_counter() const {
  // @@protoc_insertion_point(field_get:sum.proto.Manifest.release_counter)
  return _internal_release_counter();
}
inline void Manifest::_internal_set_release_counter(uint64_t value) {
  
  _impl_.release_counter_ = value;
}
inline void Manifest::set_release_counter(uint64_t value) {
  _internal_set_release_counter(value);
  // @@protoc_insertion_point(field_set:sum.proto.Manifest.release_counter)
}

// bytes manifest_hash = 4;
inline void Manifest::clear_manifest_hash() {
  _impl_.manifest_hash_.ClearToEmpty();
}
inline const std::string& Manifest::manifest_hash() const {
  // @@protoc_insertion_point(field_get:sum.proto.Manifest.manifest_hash)
  return _internal_manifest_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Manifest::set_manifest_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.manifest_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.Manifest.manifest_hash)
}
inline std::string* Manifest::mutable_manifest_hash() {
  std::string* _s = _internal_mutable_manifest_hash();
  // @@protoc_insertion_point(field_mutable:sum.proto.Manifest.manifest_hash)
  return _s;
}
inline const std::string& Manifest::_internal_manifest_hash() const {
  return _impl_.manifest_hash_.Get();
}
inline void Manifest::_internal_set_manifest_hash(const std::string& value) {
  
  _impl_.manifest_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Manifest::_internal_mutable_manifest_hash() {
  
  return _impl_.manifest_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Manifest::release_manifest_hash() {
  // @@protoc_insertion_point(field_release:sum.proto.Manifest.manifest_hash)
  return _impl_.manifest_hash_.Release();
}
inline void Manifest::set_allocated_manifest_hash(std::string* manifest_hash) {
  if (manifest_hash != nullptr) {
    
  } else {
    
  }
  _impl_.manifest_hash_.SetAllocated(manifest_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manifest_hash_.IsDefault()) {
    _impl_.manifest_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.Manifest.manifest_hash)
}

// repeated .sum.proto.Artifact artifacts = 10;
inline int Manifest::_internal_artifacts_size() const {
  return _impl_.artifacts_.size();
}
inline int Manifest::artifacts_size() const {
  return _internal_artifacts_size();
}
inline void Manifest::clear_artifacts() {
  _impl_.artifacts_.Clear();
}
inline ::sum::proto::Artifact* Manifest::mutable_artifacts(int index) {
  // @@protoc_insertion_point(field_mutable:sum.proto.Manifest.artifacts)
  return _impl_.artifacts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sum::proto::Artifact >*
Manifest::mutable_artifacts() {
  // @@protoc_insertion_point(field_mutable_list:sum.proto.Manifest.artifacts)
  return &_impl_.artifacts_;
}
inline const ::sum::proto::Artifact& Manifest::_internal_artifacts(int index) const {
  return _impl_.artifacts_.Get(index);
}
inline const ::sum::proto::Artifact& Manifest::artifacts(int index) const {
  // @@protoc_insertion_point(field_get:sum.proto.Manifest.artifacts)
  return _internal_artifacts(index);
}
inline ::sum::proto::Artifact* Manifest::_internal_add_artifacts() {
  return _impl_.artifacts_.Add();
}
inline ::sum::proto::Artifact* Manifest::add_artifacts() {
  ::sum::proto::Artifact* _add = _internal_add_artifacts();
  // @@protoc_insertion_point(field_add:sum.proto.Manifest.artifacts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sum::proto::Artifact >&
Manifest::artifacts() const {
  // @@protoc_insertion_point(field_list:sum.proto.Manifest.artifacts)
  return _impl_.artifacts_;
}

// repeated .sum.proto.EncryptionParams encryption = 11;
inline int Manifest::_internal_encryption_size() const {
  return _impl_.encryption_.size();
}
inline int Manifest::encryption_size() const {
  return _internal_encryption_size();
}
inline void Manifest::clear_encryption() {
  _impl_.encryption_.Clear();
}
inline ::sum::proto::EncryptionParams* Manifest::mutable_encryption(int index) {
  // @@protoc_insertion_point(field_mutable:sum.proto.Manifest.encryption)
  return _impl_.encryption_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sum::proto::EncryptionParams >*
Manifest::mutable_encryption() {
  // @@protoc_insertion_point(field_mutable_list:sum.proto.Manifest.encryption)
  return &_impl_.encryption_;
}
inline const ::sum::proto::EncryptionParams& Manifest::_internal_encryption(int index) const {
  return _impl_.encryption_.Get(index);
}
inline const ::sum::proto::EncryptionParams& Manifest::encryption(int index) const {
  // @@protoc_insertion_point(field_get:sum.proto.Manifest.encryption)
  return _internal_encryption(index);
}
inline ::sum::proto::EncryptionParams* Manifest::_internal_add_encryption() {
  return _impl_.encryption_.Add();
}
inline ::sum::proto::EncryptionParams* Manifest::add_encryption() {
  ::sum::proto::EncryptionParams* _add = _internal_add_encryption();
  // @@protoc_insertion_point(field_add:sum.proto.Manifest.encryption)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sum::proto::EncryptionParams >&
Manifest::encryption() const {
  // @@protoc_insertion_point(field_list:sum.proto.Manifest.encryption)
  return _impl_.encryption_;
}

// bytes signature = 20;
inline void Manifest::clear_signature() {
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& Manifest::signature() const {
  // @@protoc_insertion_point(field_get:sum.proto.Manifest.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Manifest::set_signature(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.Manifest.signature)
}
inline std::string* Manifest::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:sum.proto.Manifest.signature)
  return _s;
}
inline const std::string& Manifest::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void Manifest::_internal_set_signature(const std::string& value) {
  
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* Manifest::_internal_mutable_signature() {
  
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* Manifest::release_signature() {
  // @@protoc_insertion_point(field_release:sum.proto.Manifest.signature)
  return _impl_.signature_.Release();
}
inline void Manifest::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.Manifest.signature)
}

// bytes signing_cert = 21;
inline void Manifest::clear_signing_cert() {
  _impl_.signing_cert_.ClearToEmpty();
}
inline const std::string& Manifest::signing_cert() const {
  // @@protoc_insertion_point(field_get:sum.proto.Manifest.signing_cert)
  return _internal_signing_cert();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Manifest::set_signing_cert(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signing_cert_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.Manifest.signing_cert)
}
inline std::string* Manifest::mutable_signing_cert() {
  std::string* _s = _internal_mutable_signing_cert();
  // @@protoc_insertion_point(field_mutable:sum.proto.Manifest.signing_cert)
  return _s;
}
inline const std::string& Manifest::_internal_signing_cert() const {
  return _impl_.signing_cert_.Get();
}
inline void Manifest::_internal_set_signing_cert(const std::string& value) {
  
  _impl_.signing_cert_.Set(value, GetArenaForAllocation());
}
inline std::string* Manifest::_internal_mutable_signing_cert() {
  
  return _impl_.signing_cert_.Mutable(GetArenaForAllocation());
}
inline std::string* Manifest::release_signing_cert() {
  // @@protoc_insertion_point(field_release:sum.proto.Manifest.signing_cert)
  return _impl_.signing_cert_.Release();
}
inline void Manifest::set_allocated_signing_cert(std::string* signing_cert) {
  if (signing_cert != nullptr) {
    
  } else {
    
  }
  _impl_.signing_cert_.SetAllocated(signing_cert, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signing_cert_.IsDefault()) {
    _impl_.signing_cert_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.Manifest.signing_cert)
}

// map<string, string> metadata = 30;
inline int Manifest::_internal_metadata_size() const {
  return _impl_.metadata_.size();
}
inline int Manifest::metadata_size() const {
  return _internal_metadata_size();
}
inline void Manifest::clear_metadata() {
  _impl_.metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Manifest::_internal_metadata() const {
  return _impl_.metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Manifest::metadata() const {
  // @@protoc_insertion_point(field_map:sum.proto.Manifest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Manifest::_internal_mutable_metadata() {
  return _impl_.metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Manifest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:sum.proto.Manifest.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// Source

// string uri = 1;
inline void Source::clear_uri() {
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& Source::uri() const {
  // @@protoc_insertion_point(field_get:sum.proto.Source.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Source::set_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.Source.uri)
}
inline std::string* Source::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:sum.proto.Source.uri)
  return _s;
}
inline const std::string& Source::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void Source::_internal_set_uri(const std::string& value) {
  
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* Source::_internal_mutable_uri() {
  
  return _impl_.uri_.Mutable(GetArenaForAllocation());
}
inline std::string* Source::release_uri() {
  // @@protoc_insertion_point(field_release:sum.proto.Source.uri)
  return _impl_.uri_.Release();
}
inline void Source::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.Source.uri)
}

// uint32 priority = 2;
inline void Source::clear_priority() {
  _impl_.priority_ = 0u;
}
inline uint32_t Source::_internal_priority() const {
  return _impl_.priority_;
}
inline uint32_t Source::priority() const {
  // @@protoc_insertion_point(field_get:sum.proto.Source.priority)
  return _internal_priority();
}
inline void Source::_internal_set_priority(uint32_t value) {
  
  _impl_.priority_ = value;
}
inline void Source::set_priority(uint32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:sum.proto.Source.priority)
}

// string type = 3;
inline void Source::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Source::type() const {
  // @@protoc_insertion_point(field_get:sum.proto.Source.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Source::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.Source.type)
}
inline std::string* Source::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:sum.proto.Source.type)
  return _s;
}
inline const std::string& Source::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Source::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Source::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Source::release_type() {
  // @@protoc_insertion_point(field_release:sum.proto.Source.type)
  return _impl_.type_.Release();
}
inline void Source::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.Source.type)
}

// -------------------------------------------------------------------

// Artifact

// string name = 1;
inline void Artifact::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Artifact::name() const {
  // @@protoc_insertion_point(field_get:sum.proto.Artifact.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Artifact::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.Artifact.name)
}
inline std::string* Artifact::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sum.proto.Artifact.name)
  return _s;
}
inline const std::string& Artifact::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Artifact::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Artifact::release_name() {
  // @@protoc_insertion_point(field_release:sum.proto.Artifact.name)
  return _impl_.name_.Release();
}
inline void Artifact::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.Artifact.name)
}

// string type = 2;
inline void Artifact::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Artifact::type() const {
  // @@protoc_insertion_point(field_get:sum.proto.Artifact.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Artifact::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.Artifact.type)
}
inline std::string* Artifact::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:sum.proto.Artifact.type)
  return _s;
}
inline const std::string& Artifact::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Artifact::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Artifact::release_type() {
  // @@protoc_insertion_point(field_release:sum.proto.Artifact.type)
  return _impl_.type_.Release();
}
inline void Artifact::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.Artifact.type)
}

// string target_ecu = 3;
inline void Artifact::clear_target_ecu() {
  _impl_.target_ecu_.ClearToEmpty();
}
inline const std::string& Artifact::target_ecu() const {
  // @@protoc_insertion_point(field_get:sum.proto.Artifact.target_ecu)
  return _internal_target_ecu();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Artifact::set_target_ecu(ArgT0&& arg0, ArgT... args) {
 
 _impl_.target_ecu_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.Artifact.target_ecu)
}
inline std::string* Artifact::mutable_target_ecu() {
  std::string* _s = _internal_mutable_target_ecu();
  // @@protoc_insertion_point(field_mutable:sum.proto.Artifact.target_ecu)
  return _s;
}
inline const std::string& Artifact::_internal_target_ecu() const {
  return _impl_.target_ecu_.Get();
}
inline void Artifact::_internal_set_target_ecu(const std::string& value) {
  
  _impl_.target_ecu_.Set(value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_target_ecu() {
  
  return _impl_.target_ecu_.Mutable(GetArenaForAllocation());
}
inline std::string* Artifact::release_target_ecu() {
  // @@protoc_insertion_point(field_release:sum.proto.Artifact.target_ecu)
  return _impl_.target_ecu_.Release();
}
inline void Artifact::set_allocated_target_ecu(std::string* target_ecu) {
  if (target_ecu != nullptr) {
    
  } else {
    
  }
  _impl_.target_ecu_.SetAllocated(target_ecu, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_ecu_.IsDefault()) {
    _impl_.target_ecu_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.Artifact.target_ecu)
}

// uint32 install_order = 4;
inline void Artifact::clear_install_order() {
  _impl_.install_order_ = 0u;
}
inline uint32_t Artifact::_internal_install_order() const {
  return _impl_.install_order_;
}
inline uint32_t Artifact::install_order() const {
  // @@protoc_insertion_point(field_get:sum.proto.Artifact.install_order)
  return _internal_install_order();
}
inline void Artifact::_internal_set_install_order(uint32_t value) {
  
  _impl_.install_order_ = value;
}
inline void Artifact::set_install_order(uint32_t value) {
  _internal_set_install_order(value);
  // @@protoc_insertion_point(field_set:sum.proto.Artifact.install_order)
}

// string hash_algorithm = 10;
inline void Artifact::clear_hash_algorithm() {
  _impl_.hash_algorithm_.ClearToEmpty();
}
inline const std::string& Artifact::hash_algorithm() const {
  // @@protoc_insertion_point(field_get:sum.proto.Artifact.hash_algorithm)
  return _internal_hash_algorithm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Artifact::set_hash_algorithm(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_algorithm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.Artifact.hash_algorithm)
}
inline std::string* Artifact::mutable_hash_algorithm() {
  std::string* _s = _internal_mutable_hash_algorithm();
  // @@protoc_insertion_point(field_mutable:sum.proto.Artifact.hash_algorithm)
  return _s;
}
inline const std::string& Artifact::_internal_hash_algorithm() const {
  return _impl_.hash_algorithm_.Get();
}
inline void Artifact::_internal_set_hash_algorithm(const std::string& value) {
  
  _impl_.hash_algorithm_.Set(value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_hash_algorithm() {
  
  return _impl_.hash_algorithm_.Mutable(GetArenaForAllocation());
}
inline std::string* Artifact::release_hash_algorithm() {
  // @@protoc_insertion_point(field_release:sum.proto.Artifact.hash_algorithm)
  return _impl_.hash_algorithm_.Release();
}
inline void Artifact::set_allocated_hash_algorithm(std::string* hash_algorithm) {
  if (hash_algorithm != nullptr) {
    
  } else {
    
  }
  _impl_.hash_algorithm_.SetAllocated(hash_algorithm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_algorithm_.IsDefault()) {
    _impl_.hash_algorithm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.Artifact.hash_algorithm)
}

// bytes expected_hash = 11;
inline void Artifact::clear_expected_hash() {
  _impl_.expected_hash_.ClearToEmpty();
}
inline const std::string& Artifact::expected_hash() const {
  // @@protoc_insertion_point(field_get:sum.proto.Artifact.expected_hash)
  return _internal_expected_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Artifact::set_expected_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.expected_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.Artifact.expected_hash)
}
inline std::string* Artifact::mutable_expected_hash() {
  std::string* _s = _internal_mutable_expected_hash();
  // @@protoc_insertion_point(field_mutable:sum.proto.Artifact.expected_hash)
  return _s;
}
inline const std::string& Artifact::_internal_expected_hash() const {
  return _impl_.expected_hash_.Get();
}
inline void Artifact::_internal_set_expected_hash(const std::string& value) {
  
  _impl_.expected_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_expected_hash() {
  
  return _impl_.expected_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Artifact::release_expected_hash() {
  // @@protoc_insertion_point(field_release:sum.proto.Artifact.expected_hash)
  return _impl_.expected_hash_.Release();
}
inline void Artifact::set_allocated_expected_hash(std::string* expected_hash) {
  if (expected_hash != nullptr) {
    
  } else {
    
  }
  _impl_.expected_hash_.SetAllocated(expected_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.expected_hash_.IsDefault()) {
    _impl_.expected_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.Artifact.expected_hash)
}

// uint64 size = 12;
inline void Artifact::clear_size() {
  _impl_.size_ = uint64_t{0u};
}
inline uint64_t Artifact::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t Artifact::size() const {
  // @@protoc_insertion_point(field_get:sum.proto.Artifact.size)
  return _internal_size();
}
inline void Artifact::_internal_set_size(uint64_t value) {
  
  _impl_.size_ = value;
}
inline void Artifact::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:sum.proto.Artifact.size)
}

// bytes ciphertext_hash = 13;
inline void Artifact::clear_ciphertext_hash() {
  _impl_.ciphertext_hash_.ClearToEmpty();
}
inline const std::string& Artifact::ciphertext_hash() const {
  // @@protoc_insertion_point(field_get:sum.proto.Artifact.ciphertext_hash)
  return _internal_ciphertext_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Artifact::set_ciphertext_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ciphertext_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.Artifact.ciphertext_hash)
}
inline std::string* Artifact::mutable_ciphertext_hash() {
  std::string* _s = _internal_mutable_ciphertext_hash();
  // @@protoc_insertion_point(field_mutable:sum.proto.Artifact.ciphertext_hash)
  return _s;
}
inline const std::string& Artifact::_internal_ciphertext_hash() const {
  return _impl_.ciphertext_hash_.Get();
}
inline void Artifact::_internal_set_ciphertext_hash(const std::string& value) {
  
  _impl_.ciphertext_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_ciphertext_hash() {
  
  return _impl_.ciphertext_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Artifact::release_ciphertext_hash() {
  // @@protoc_insertion_point(field_release:sum.proto.Artifact.ciphertext_hash)
  return _impl_.ciphertext_hash_.Release();
}
inline void Artifact::set_allocated_ciphertext_hash(std::string* ciphertext_hash) {
  if (ciphertext_hash != nullptr) {
    
  } else {
    
  }
  _impl_.ciphertext_hash_.SetAllocated(ciphertext_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ciphertext_hash_.IsDefault()) {
    _impl_.ciphertext_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.Artifact.ciphertext_hash)
}

// uint64 ciphertext_size = 14;
inline void Artifact::clear_ciphertext_size() {
  _impl_.ciphertext_size_ = uint64_t{0u};
}
inline uint64_t Artifact::_internal_ciphertext_size() const {
  return _impl_.ciphertext_size_;
}
inline uint64_t Artifact::ciphertext_size() const {
  // @@protoc_insertion_point(field_get:sum.proto.Artifact.ciphertext_size)
  return _internal_ciphertext_size();
}
inline void Artifact::_internal_set_ciphertext_size(uint64_t value) {
  
  _impl_.ciphertext_size_ = value;
}
inline void Artifact::set_ciphertext_size(uint64_t value) {
  _internal_set_ciphertext_size(value);
  // @@protoc_insertion_point(field_set:sum.proto.Artifact.ciphertext_size)
}

// string signature_algorithm = 20;
inline void Artifact::clear_signature_algorithm() {
  _impl_.signature_algorithm_.ClearToEmpty();
}
inline const std::string& Artifact::signature_algorithm() const {
  // @@protoc_insertion_point(field_get:sum.proto.Artifact.signature_algorithm)
  return _internal_signature_algorithm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Artifact::set_signature_algorithm(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signature_algorithm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.Artifact.signature_algorithm)
}
inline std::string* Artifact::mutable_signature_algorithm() {
  std::string* _s = _internal_mutable_signature_algorithm();
  // @@protoc_insertion_point(field_mutable:sum.proto.Artifact.signature_algorithm)
  return _s;
}
inline const std::string& Artifact::_internal_signature_algorithm() const {
  return _impl_.signature_algorithm_.Get();
}
inline void Artifact::_internal_set_signature_algorithm(const std::string& value) {
  
  _impl_.signature_algorithm_.Set(value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_signature_algorithm() {
  
  return _impl_.signature_algorithm_.Mutable(GetArenaForAllocation());
}
inline std::string* Artifact::release_signature_algorithm() {
  // @@protoc_insertion_point(field_release:sum.proto.Artifact.signature_algorithm)
  return _impl_.signature_algorithm_.Release();
}
inline void Artifact::set_allocated_signature_algorithm(std::string* signature_algorithm) {
  if (signature_algorithm != nullptr) {
    
  } else {
    
  }
  _impl_.signature_algorithm_.SetAllocated(signature_algorithm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_algorithm_.IsDefault()) {
    _impl_.signature_algorithm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.Artifact.signature_algorithm)
}

// bytes signature = 21;
inline void Artifact::clear_signature() {
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& Artifact::signature() const {
  // @@protoc_insertion_point(field_get:sum.proto.Artifact.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Artifact::set_signature(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.Artifact.signature)
}
inline std::string* Artifact::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:sum.proto.Artifact.signature)
  return _s;
}
inline const std::string& Artifact::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void Artifact::_internal_set_signature(const std::string& value) {
  
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* Artifact::_internal_mutable_signature() {
  
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* Artifact::release_signature() {
  // @@protoc_insertion_point(field_release:sum.proto.Artifact.signature)
  return _impl_.signature_.Release();
}
inline void Artifact::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.Artifact.signature)
}

// repeated .sum.proto.Source sources = 40;
inline int Artifact::_internal_sources_size() const {
  return _impl_.sources_.size();
}
inline int Artifact::sources_size() const {
  return _internal_sources_size();
}
inline void Artifact::clear_sources() {
  _impl_.sources_.Clear();
}
inline ::sum::proto::Source* Artifact::mutable_sources(int index) {
  // @@protoc_insertion_point(field_mutable:sum.proto.Artifact.sources)
  return _impl_.sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sum::proto::Source >*
Artifact::mutable_sources() {
  // @@protoc_insertion_point(field_mutable_list:sum.proto.Artifact.sources)
  return &_impl_.sources_;
}
inline const ::sum::proto::Source& Artifact::_internal_sources(int index) const {
  return _impl_.sources_.Get(index);
}
inline const ::sum::proto::Source& Artifact::sources(int index) const {
  // @@protoc_insertion_point(field_get:sum.proto.Artifact.sources)
  return _internal_sources(index);
}
inline ::sum::proto::Source* Artifact::_internal_add_sources() {
  return _impl_.sources_.Add();
}
inline ::sum::proto::Source* Artifact::add_sources() {
  ::sum::proto::Source* _add = _internal_add_sources();
  // @@protoc_insertion_point(field_add:sum.proto.Artifact.sources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sum::proto::Source >&
Artifact::sources() const {
  // @@protoc_insertion_point(field_list:sum.proto.Artifact.sources)
  return _impl_.sources_;
}

// bool content_addressable = 41;
inline void Artifact::clear_content_addressable() {
  _impl_.content_addressable_ = false;
}
inline bool Artifact::_internal_content_addressable() const {
  return _impl_.content_addressable_;
}
inline bool Artifact::content_addressable() const {
  // @@protoc_insertion_point(field_get:sum.proto.Artifact.content_addressable)
  return _internal_content_addressable();
}
inline void Artifact::_internal_set_content_addressable(bool value) {
  
  _impl_.content_addressable_ = value;
}
inline void Artifact::set_content_addressable(bool value) {
  _internal_set_content_addressable(value);
  // @@protoc_insertion_point(field_set:sum.proto.Artifact.content_addressable)
}

// -------------------------------------------------------------------

// EncryptionParams

// string artifact_name = 1;
inline void EncryptionParams::clear_artifact_name() {
  _impl_.artifact_name_.ClearToEmpty();
}
inline const std::string& EncryptionParams::artifact_name() const {
  // @@protoc_insertion_point(field_get:sum.proto.EncryptionParams.artifact_name)
  return _internal_artifact_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EncryptionParams::set_artifact_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.artifact_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.EncryptionParams.artifact_name)
}
inline std::string* EncryptionParams::mutable_artifact_name() {
  std::string* _s = _internal_mutable_artifact_name();
  // @@protoc_insertion_point(field_mutable:sum.proto.EncryptionParams.artifact_name)
  return _s;
}
inline const std::string& EncryptionParams::_internal_artifact_name() const {
  return _impl_.artifact_name_.Get();
}
inline void EncryptionParams::_internal_set_artifact_name(const std::string& value) {
  
  _impl_.artifact_name_.Set(value, GetArenaForAllocation());
}
inline std::string* EncryptionParams::_internal_mutable_artifact_name() {
  
  return _impl_.artifact_name_.Mutable(GetArenaForAllocation());
}
inline std::string* EncryptionParams::release_artifact_name() {
  // @@protoc_insertion_point(field_release:sum.proto.EncryptionParams.artifact_name)
  return _impl_.artifact_name_.Release();
}
inline void EncryptionParams::set_allocated_artifact_name(std::string* artifact_name) {
  if (artifact_name != nullptr) {
    
  } else {
    
  }
  _impl_.artifact_name_.SetAllocated(artifact_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.artifact_name_.IsDefault()) {
    _impl_.artifact_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.EncryptionParams.artifact_name)
}

// string device_id = 2;
inline void EncryptionParams::clear_device_id() {
  _impl_.device_id_.ClearToEmpty();
}
inline const std::string& EncryptionParams::device_id() const {
  // @@protoc_insertion_point(field_get:sum.proto.EncryptionParams.device_id)
  return _internal_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EncryptionParams::set_device_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.device_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.EncryptionParams.device_id)
}
inline std::string* EncryptionParams::mutable_device_id() {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:sum.proto.EncryptionParams.device_id)
  return _s;
}
inline const std::string& EncryptionParams::_internal_device_id() const {
  return _impl_.device_id_.Get();
}
inline void EncryptionParams::_internal_set_device_id(const std::string& value) {
  
  _impl_.device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EncryptionParams::_internal_mutable_device_id() {
  
  return _impl_.device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EncryptionParams::release_device_id() {
  // @@protoc_insertion_point(field_release:sum.proto.EncryptionParams.device_id)
  return _impl_.device_id_.Release();
}
inline void EncryptionParams::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    
  } else {
    
  }
  _impl_.device_id_.SetAllocated(device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_id_.IsDefault()) {
    _impl_.device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.EncryptionParams.device_id)
}

// string algorithm = 10;
inline void EncryptionParams::clear_algorithm() {
  _impl_.algorithm_.ClearToEmpty();
}
inline const std::string& EncryptionParams::algorithm() const {
  // @@protoc_insertion_point(field_get:sum.proto.EncryptionParams.algorithm)
  return _internal_algorithm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EncryptionParams::set_algorithm(ArgT0&& arg0, ArgT... args) {
 
 _impl_.algorithm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.EncryptionParams.algorithm)
}
inline std::string* EncryptionParams::mutable_algorithm() {
  std::string* _s = _internal_mutable_algorithm();
  // @@protoc_insertion_point(field_mutable:sum.proto.EncryptionParams.algorithm)
  return _s;
}
inline const std::string& EncryptionParams::_internal_algorithm() const {
  return _impl_.algorithm_.Get();
}
inline void EncryptionParams::_internal_set_algorithm(const std::string& value) {
  
  _impl_.algorithm_.Set(value, GetArenaForAllocation());
}
inline std::string* EncryptionParams::_internal_mutable_algorithm() {
  
  return _impl_.algorithm_.Mutable(GetArenaForAllocation());
}
inline std::string* EncryptionParams::release_algorithm() {
  // @@protoc_insertion_point(field_release:sum.proto.EncryptionParams.algorithm)
  return _impl_.algorithm_.Release();
}
inline void EncryptionParams::set_allocated_algorithm(std::string* algorithm) {
  if (algorithm != nullptr) {
    
  } else {
    
  }
  _impl_.algorithm_.SetAllocated(algorithm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.algorithm_.IsDefault()) {
    _impl_.algorithm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.EncryptionParams.algorithm)
}

// bytes iv = 11;
inline void EncryptionParams::clear_iv() {
  _impl_.iv_.ClearToEmpty();
}
inline const std::string& EncryptionParams::iv() const {
  // @@protoc_insertion_point(field_get:sum.proto.EncryptionParams.iv)
  return _internal_iv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EncryptionParams::set_iv(ArgT0&& arg0, ArgT... args) {
 
 _impl_.iv_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.EncryptionParams.iv)
}
inline std::string* EncryptionParams::mutable_iv() {
  std::string* _s = _internal_mutable_iv();
  // @@protoc_insertion_point(field_mutable:sum.proto.EncryptionParams.iv)
  return _s;
}
inline const std::string& EncryptionParams::_internal_iv() const {
  return _impl_.iv_.Get();
}
inline void EncryptionParams::_internal_set_iv(const std::string& value) {
  
  _impl_.iv_.Set(value, GetArenaForAllocation());
}
inline std::string* EncryptionParams::_internal_mutable_iv() {
  
  return _impl_.iv_.Mutable(GetArenaForAllocation());
}
inline std::string* EncryptionParams::release_iv() {
  // @@protoc_insertion_point(field_release:sum.proto.EncryptionParams.iv)
  return _impl_.iv_.Release();
}
inline void EncryptionParams::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    
  } else {
    
  }
  _impl_.iv_.SetAllocated(iv, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iv_.IsDefault()) {
    _impl_.iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.EncryptionParams.iv)
}

// bytes tag = 12;
inline void EncryptionParams::clear_tag() {
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& EncryptionParams::tag() const {
  // @@protoc_insertion_point(field_get:sum.proto.EncryptionParams.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EncryptionParams::set_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tag_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.EncryptionParams.tag)
}
inline std::string* EncryptionParams::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:sum.proto.EncryptionParams.tag)
  return _s;
}
inline const std::string& EncryptionParams::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void EncryptionParams::_internal_set_tag(const std::string& value) {
  
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* EncryptionParams::_internal_mutable_tag() {
  
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* EncryptionParams::release_tag() {
  // @@protoc_insertion_point(field_release:sum.proto.EncryptionParams.tag)
  return _impl_.tag_.Release();
}
inline void EncryptionParams::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.EncryptionParams.tag)
}

// string key_wrapping_algorithm = 20;
inline void EncryptionParams::clear_key_wrapping_algorithm() {
  _impl_.key_wrapping_algorithm_.ClearToEmpty();
}
inline const std::string& EncryptionParams::key_wrapping_algorithm() const {
  // @@protoc_insertion_point(field_get:sum.proto.EncryptionParams.key_wrapping_algorithm)
  return _internal_key_wrapping_algorithm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EncryptionParams::set_key_wrapping_algorithm(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_wrapping_algorithm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.EncryptionParams.key_wrapping_algorithm)
}
inline std::string* EncryptionParams::mutable_key_wrapping_algorithm() {
  std::string* _s = _internal_mutable_key_wrapping_algorithm();
  // @@protoc_insertion_point(field_mutable:sum.proto.EncryptionParams.key_wrapping_algorithm)
  return _s;
}
inline const std::string& EncryptionParams::_internal_key_wrapping_algorithm() const {
  return _impl_.key_wrapping_algorithm_.Get();
}
inline void EncryptionParams::_internal_set_key_wrapping_algorithm(const std::string& value) {
  
  _impl_.key_wrapping_algorithm_.Set(value, GetArenaForAllocation());
}
inline std::string* EncryptionParams::_internal_mutable_key_wrapping_algorithm() {
  
  return _impl_.key_wrapping_algorithm_.Mutable(GetArenaForAllocation());
}
inline std::string* EncryptionParams::release_key_wrapping_algorithm() {
  // @@protoc_insertion_point(field_release:sum.proto.EncryptionParams.key_wrapping_algorithm)
  return _impl_.key_wrapping_algorithm_.Release();
}
inline void EncryptionParams::set_allocated_key_wrapping_algorithm(std::string* key_wrapping_algorithm) {
  if (key_wrapping_algorithm != nullptr) {
    
  } else {
    
  }
  _impl_.key_wrapping_algorithm_.SetAllocated(key_wrapping_algorithm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_wrapping_algorithm_.IsDefault()) {
    _impl_.key_wrapping_algorithm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.EncryptionParams.key_wrapping_algorithm)
}

// bytes wrapped_key = 21;
inline void EncryptionParams::clear_wrapped_key() {
  _impl_.wrapped_key_.ClearToEmpty();
}
inline const std::string& EncryptionParams::wrapped_key() const {
  // @@protoc_insertion_point(field_get:sum.proto.EncryptionParams.wrapped_key)
  return _internal_wrapped_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EncryptionParams::set_wrapped_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wrapped_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.EncryptionParams.wrapped_key)
}
inline std::string* EncryptionParams::mutable_wrapped_key() {
  std::string* _s = _internal_mutable_wrapped_key();
  // @@protoc_insertion_point(field_mutable:sum.proto.EncryptionParams.wrapped_key)
  return _s;
}
inline const std::string& EncryptionParams::_internal_wrapped_key() const {
  return _impl_.wrapped_key_.Get();
}
inline void EncryptionParams::_internal_set_wrapped_key(const std::string& value) {
  
  _impl_.wrapped_key_.Set(value, GetArenaForAllocation());
}
inline std::string* EncryptionParams::_internal_mutable_wrapped_key() {
  
  return _impl_.wrapped_key_.Mutable(GetArenaForAllocation());
}
inline std::string* EncryptionParams::release_wrapped_key() {
  // @@protoc_insertion_point(field_release:sum.proto.EncryptionParams.wrapped_key)
  return _impl_.wrapped_key_.Release();
}
inline void EncryptionParams::set_allocated_wrapped_key(std::string* wrapped_key) {
  if (wrapped_key != nullptr) {
    
  } else {
    
  }
  _impl_.wrapped_key_.SetAllocated(wrapped_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wrapped_key_.IsDefault()) {
    _impl_.wrapped_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.EncryptionParams.wrapped_key)
}

// -------------------------------------------------------------------

// DeviceMetadata

// string device_type = 1;
inline void DeviceMetadata::clear_device_type() {
  _impl_.device_type_.ClearToEmpty();
}
inline const std::string& DeviceMetadata::device_type() const {
  // @@protoc_insertion_point(field_get:sum.proto.DeviceMetadata.device_type)
  return _internal_device_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceMetadata::set_device_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.device_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.DeviceMetadata.device_type)
}
inline std::string* DeviceMetadata::mutable_device_type() {
  std::string* _s = _internal_mutable_device_type();
  // @@protoc_insertion_point(field_mutable:sum.proto.DeviceMetadata.device_type)
  return _s;
}
inline const std::string& DeviceMetadata::_internal_device_type() const {
  return _impl_.device_type_.Get();
}
inline void DeviceMetadata::_internal_set_device_type(const std::string& value) {
  
  _impl_.device_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceMetadata::_internal_mutable_device_type() {
  
  return _impl_.device_type_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceMetadata::release_device_type() {
  // @@protoc_insertion_point(field_release:sum.proto.DeviceMetadata.device_type)
  return _impl_.device_type_.Release();
}
inline void DeviceMetadata::set_allocated_device_type(std::string* device_type) {
  if (device_type != nullptr) {
    
  } else {
    
  }
  _impl_.device_type_.SetAllocated(device_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_type_.IsDefault()) {
    _impl_.device_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.DeviceMetadata.device_type)
}

// string hardware_id = 2;
inline void DeviceMetadata::clear_hardware_id() {
  _impl_.hardware_id_.ClearToEmpty();
}
inline const std::string& DeviceMetadata::hardware_id() const {
  // @@protoc_insertion_point(field_get:sum.proto.DeviceMetadata.hardware_id)
  return _internal_hardware_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceMetadata::set_hardware_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hardware_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.DeviceMetadata.hardware_id)
}
inline std::string* DeviceMetadata::mutable_hardware_id() {
  std::string* _s = _internal_mutable_hardware_id();
  // @@protoc_insertion_point(field_mutable:sum.proto.DeviceMetadata.hardware_id)
  return _s;
}
inline const std::string& DeviceMetadata::_internal_hardware_id() const {
  return _impl_.hardware_id_.Get();
}
inline void DeviceMetadata::_internal_set_hardware_id(const std::string& value) {
  
  _impl_.hardware_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceMetadata::_internal_mutable_hardware_id() {
  
  return _impl_.hardware_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceMetadata::release_hardware_id() {
  // @@protoc_insertion_point(field_release:sum.proto.DeviceMetadata.hardware_id)
  return _impl_.hardware_id_.Release();
}
inline void DeviceMetadata::set_allocated_hardware_id(std::string* hardware_id) {
  if (hardware_id != nullptr) {
    
  } else {
    
  }
  _impl_.hardware_id_.SetAllocated(hardware_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hardware_id_.IsDefault()) {
    _impl_.hardware_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.DeviceMetadata.hardware_id)
}

// string manufacturer = 3;
inline void DeviceMetadata::clear_manufacturer() {
  _impl_.manufacturer_.ClearToEmpty();
}
inline const std::string& DeviceMetadata::manufacturer() const {
  // @@protoc_insertion_point(field_get:sum.proto.DeviceMetadata.manufacturer)
  return _internal_manufacturer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceMetadata::set_manufacturer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.manufacturer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.DeviceMetadata.manufacturer)
}
inline std::string* DeviceMetadata::mutable_manufacturer() {
  std::string* _s = _internal_mutable_manufacturer();
  // @@protoc_insertion_point(field_mutable:sum.proto.DeviceMetadata.manufacturer)
  return _s;
}
inline const std::string& DeviceMetadata::_internal_manufacturer() const {
  return _impl_.manufacturer_.Get();
}
inline void DeviceMetadata::_internal_set_manufacturer(const std::string& value) {
  
  _impl_.manufacturer_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceMetadata::_internal_mutable_manufacturer() {
  
  return _impl_.manufacturer_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceMetadata::release_manufacturer() {
  // @@protoc_insertion_point(field_release:sum.proto.DeviceMetadata.manufacturer)
  return _impl_.manufacturer_.Release();
}
inline void DeviceMetadata::set_allocated_manufacturer(std::string* manufacturer) {
  if (manufacturer != nullptr) {
    
  } else {
    
  }
  _impl_.manufacturer_.SetAllocated(manufacturer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manufacturer_.IsDefault()) {
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.DeviceMetadata.manufacturer)
}

// string hardware_version = 4;
inline void DeviceMetadata::clear_hardware_version() {
  _impl_.hardware_version_.ClearToEmpty();
}
inline const std::string& DeviceMetadata::hardware_version() const {
  // @@protoc_insertion_point(field_get:sum.proto.DeviceMetadata.hardware_version)
  return _internal_hardware_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceMetadata::set_hardware_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hardware_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sum.proto.DeviceMetadata.hardware_version)
}
inline std::string* DeviceMetadata::mutable_hardware_version() {
  std::string* _s = _internal_mutable_hardware_version();
  // @@protoc_insertion_point(field_mutable:sum.proto.DeviceMetadata.hardware_version)
  return _s;
}
inline const std::string& DeviceMetadata::_internal_hardware_version() const {
  return _impl_.hardware_version_.Get();
}
inline void DeviceMetadata::_internal_set_hardware_version(const std::string& value) {
  
  _impl_.hardware_version_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceMetadata::_internal_mutable_hardware_version() {
  
  return _impl_.hardware_version_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceMetadata::release_hardware_version() {
  // @@protoc_insertion_point(field_release:sum.proto.DeviceMetadata.hardware_version)
  return _impl_.hardware_version_.Release();
}
inline void DeviceMetadata::set_allocated_hardware_version(std::string* hardware_version) {
  if (hardware_version != nullptr) {
    
  } else {
    
  }
  _impl_.hardware_version_.SetAllocated(hardware_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hardware_version_.IsDefault()) {
    _impl_.hardware_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sum.proto.DeviceMetadata.hardware_version)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace sum

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_manifest_2eproto
