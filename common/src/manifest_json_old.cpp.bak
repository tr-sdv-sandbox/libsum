/**
 * @file manifest.cpp
 * @brief Secure Update Manifest implementation
 *
 * Copyright 2025 libsum contributors
 * SPDX-License-Identifier: Apache-2.0
 */

#include "sum/common/manifest.h"
#include <nlohmann/json.hpp>
#include <glog/logging.h>
#include <fstream>
#include <sstream>
#include <stdexcept>
#include <iomanip>
#include <map>

using json = nlohmann::json;

namespace sum {

// ============================================================================
// JSON Serialization Helpers
// ============================================================================

namespace {

// Convert binary data to hex string
std::string ToHex(const std::vector<uint8_t>& data) {
    std::ostringstream oss;
    for (uint8_t byte : data) {
        oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
    }
    return oss.str();
}

// Convert hex string to binary data
std::vector<uint8_t> FromHex(const std::string& hex) {
    std::vector<uint8_t> result;
    for (size_t i = 0; i < hex.length(); i += 2) {
        std::string byte_str = hex.substr(i, 2);
        result.push_back(static_cast<uint8_t>(std::stoi(byte_str, nullptr, 16)));
    }
    return result;
}

// Serialize SoftwareArtifact to JSON
json ToJson(const SoftwareArtifact& artifact) {
    json j = {
        {"name", artifact.name},
        {"hash_algorithm", artifact.hash_algorithm},
        {"expected_hash", ToHex(artifact.expected_hash)},
        {"signature_algorithm", artifact.signature_algorithm},
        {"signature", ToHex(artifact.signature)}
    };

    if (artifact.size.has_value()) {
        j["size"] = artifact.size.value();
    }

    if (artifact.url.has_value()) {
        j["url"] = artifact.url.value();
    }

    return j;
}

// Deserialize SoftwareArtifact from JSON
SoftwareArtifact SoftwareArtifactFromJson(const json& j) {
    SoftwareArtifact artifact;

    artifact.name = j.at("name").get<std::string>();
    artifact.hash_algorithm = j.at("hash_algorithm").get<std::string>();
    artifact.expected_hash = FromHex(j.at("expected_hash").get<std::string>());
    artifact.signature_algorithm = j.at("signature_algorithm").get<std::string>();
    artifact.signature = FromHex(j.at("signature").get<std::string>());

    if (j.contains("size")) {
        artifact.size = j.at("size").get<uint64_t>();
    }

    return artifact;
}

// Serialize EncryptionParams to JSON
json ToJson(const EncryptionParams& params) {
    json j = {
        {"artifact_name", params.artifact_name},
        {"algorithm", params.algorithm},
        {"iv", ToHex(params.iv)},
        {"wrapped_key", ToHex(params.wrapped_key)},
        {"key_wrapping_algorithm", params.key_wrapping_algorithm},
        {"tag", ToHex(params.tag)}
    };

    if (params.device_id.has_value()) {
        j["device_id"] = params.device_id.value();
    }

    return j;
}

// Deserialize EncryptionParams from JSON
EncryptionParams EncryptionParamsFromJson(const json& j) {
    EncryptionParams params;

    params.artifact_name = j.at("artifact_name").get<std::string>();
    params.algorithm = j.at("algorithm").get<std::string>();
    params.iv = FromHex(j.at("iv").get<std::string>());
    params.wrapped_key = FromHex(j.at("wrapped_key").get<std::string>());
    params.key_wrapping_algorithm = j.at("key_wrapping_algorithm").get<std::string>();
    params.tag = FromHex(j.at("tag").get<std::string>());

    if (j.contains("device_id")) {
        params.device_id = j.at("device_id").get<std::string>();
    }

    return params;
}

} // anonymous namespace

// ============================================================================
// Manifest::Impl - Internal implementation
// ============================================================================

class Manifest::Impl {
public:
    uint32_t version = 2;  // Manifest format version (v2: AES-GCM with authentication tags)
    uint64_t manifest_version = 0;  // Software/update version number
    std::vector<SoftwareArtifact> artifacts;
    std::vector<EncryptionParams> encryption_params;
    std::vector<uint8_t> signature;
    std::vector<uint8_t> signing_certificate;
    std::map<std::string, std::string> metadata;  // Extensible metadata
};

// ============================================================================
// Manifest - Public interface
// ============================================================================

Manifest::Manifest() : impl_(std::make_unique<Impl>()) {}

Manifest::~Manifest() = default;

Manifest::Manifest(Manifest&&) noexcept = default;
Manifest& Manifest::operator=(Manifest&&) noexcept = default;

// Accessors
uint32_t Manifest::GetFormatVersion() const {
    return impl_->version;
}

uint64_t Manifest::GetManifestVersion() const {
    return impl_->manifest_version;
}

const std::vector<SoftwareArtifact>& Manifest::GetArtifacts() const {
    return impl_->artifacts;
}

const std::vector<EncryptionParams>& Manifest::GetEncryptionParams() const {
    return impl_->encryption_params;
}

const std::vector<uint8_t>& Manifest::GetSignature() const {
    return impl_->signature;
}

const std::vector<uint8_t>& Manifest::GetSigningCertificate() const {
    return impl_->signing_certificate;
}

std::optional<std::string> Manifest::GetMetadata(const std::string& key) const {
    auto it = impl_->metadata.find(key);
    if (it != impl_->metadata.end()) {
        return it->second;
    }
    return std::nullopt;
}

// Mutators
void Manifest::SetManifestVersion(uint64_t version) {
    impl_->manifest_version = version;
}

void Manifest::AddArtifact(SoftwareArtifact artifact) {
    impl_->artifacts.push_back(std::move(artifact));
}

void Manifest::AddEncryptionParams(EncryptionParams params) {
    impl_->encryption_params.push_back(std::move(params));
}

void Manifest::SetSignature(const std::vector<uint8_t>& signature) {
    impl_->signature = signature;
}

void Manifest::SetSigningCertificate(const std::vector<uint8_t>& cert) {
    impl_->signing_certificate = cert;
}

void Manifest::SetMetadata(const std::string& key, const std::string& value) {
    impl_->metadata[key] = value;
}

// JSON Serialization (internal use for certificate embedding)
Manifest Manifest::LoadFromJSON(const std::vector<uint8_t>& data) {
    // SECURITY: Reject manifests larger than 1MB to prevent DoS attacks
    constexpr size_t MAX_MANIFEST_SIZE = 1024 * 1024;  // 1MB
    if (data.size() > MAX_MANIFEST_SIZE) {
        throw std::runtime_error("Manifest too large: " + std::to_string(data.size()) +
                                " bytes (max " + std::to_string(MAX_MANIFEST_SIZE) + " bytes)");
    }

    std::string json_str(data.begin(), data.end());
    return LoadFromJSON(json_str);
}

Manifest Manifest::LoadFromJSON(const std::string& json_str) {
    // SECURITY: Reject manifests larger than 1MB to prevent DoS attacks
    constexpr size_t MAX_MANIFEST_SIZE = 1024 * 1024;  // 1MB
    if (json_str.size() > MAX_MANIFEST_SIZE) {
        throw std::runtime_error("Manifest too large: " + std::to_string(json_str.size()) +
                                " bytes (max " + std::to_string(MAX_MANIFEST_SIZE) + " bytes)");
    }

    try {
        json j = json::parse(json_str);

        Manifest manifest;

        // Parse basic fields
        manifest.impl_->version = j.at("version").get<uint32_t>();
        manifest.impl_->manifest_version = j.at("manifest_version").get<uint64_t>();

        // Parse artifacts
        if (j.contains("artifacts")) {
            for (const auto& artifact_json : j.at("artifacts")) {
                manifest.impl_->artifacts.push_back(
                    SoftwareArtifactFromJson(artifact_json)
                );
            }
        }

        // Parse encryption parameters
        if (j.contains("encryption")) {
            for (const auto& params_json : j.at("encryption")) {
                manifest.impl_->encryption_params.push_back(
                    EncryptionParamsFromJson(params_json)
                );
            }
        }

        // Parse signature and certificate
        if (j.contains("signature")) {
            manifest.impl_->signature = FromHex(j.at("signature").get<std::string>());
        }
        if (j.contains("signing_certificate")) {
            manifest.impl_->signing_certificate = FromHex(j.at("signing_certificate").get<std::string>());
        }

        // Parse metadata
        if (j.contains("metadata")) {
            for (auto& [key, value] : j.at("metadata").items()) {
                manifest.impl_->metadata[key] = value.get<std::string>();
            }
        }

        LOG(INFO) << "Loaded manifest version " << manifest.impl_->manifest_version
                  << " with " << manifest.impl_->artifacts.size() << " artifacts";

        return manifest;

    } catch (const json::exception& e) {
        throw std::runtime_error(std::string("JSON parsing error: ") + e.what());
    }
}

std::vector<uint8_t> Manifest::ToJSON() const {
    std::string json_str = ToJSONString(false);
    return std::vector<uint8_t>(json_str.begin(), json_str.end());
}

std::vector<uint8_t> Manifest::ToJSONForSigning() const {
    // Serialize manifest WITHOUT signature field for signing/verification
    json j;

    j["version"] = impl_->version;
    j["manifest_version"] = impl_->manifest_version;

    // Add artifacts
    json artifacts_array = json::array();
    for (const auto& artifact : impl_->artifacts) {
        artifacts_array.push_back(ToJson(artifact));
    }
    j["artifacts"] = artifacts_array;

    // Add encryption parameters
    if (!impl_->encryption_params.empty()) {
        json encryption_array = json::array();
        for (const auto& params : impl_->encryption_params) {
            encryption_array.push_back(ToJson(params));
        }
        j["encryption"] = encryption_array;
    }

    // Add signing certificate (but NOT signature)
    if (!impl_->signing_certificate.empty()) {
        j["signing_certificate"] = ToHex(impl_->signing_certificate);
    }

    // Add metadata
    if (!impl_->metadata.empty()) {
        json metadata_obj = json::object();
        for (const auto& [key, value] : impl_->metadata) {
            metadata_obj[key] = value;
        }
        j["metadata"] = metadata_obj;
    }

    std::string json_str = j.dump(-1);  // No pretty print for signing
    return std::vector<uint8_t>(json_str.begin(), json_str.end());
}

std::string Manifest::ToJSONString(bool pretty_print) const {
    json j;

    j["version"] = impl_->version;
    j["manifest_version"] = impl_->manifest_version;

    // Add artifacts
    json artifacts_array = json::array();
    for (const auto& artifact : impl_->artifacts) {
        artifacts_array.push_back(ToJson(artifact));
    }
    j["artifacts"] = artifacts_array;

    // Add encryption parameters
    if (!impl_->encryption_params.empty()) {
        json encryption_array = json::array();
        for (const auto& params : impl_->encryption_params) {
            encryption_array.push_back(ToJson(params));
        }
        j["encryption"] = encryption_array;
    }

    // Add signature and certificate
    if (!impl_->signature.empty()) {
        j["signature"] = ToHex(impl_->signature);
    }
    if (!impl_->signing_certificate.empty()) {
        j["signing_certificate"] = ToHex(impl_->signing_certificate);
    }

    // Add metadata
    if (!impl_->metadata.empty()) {
        json metadata_obj = json::object();
        for (const auto& [key, value] : impl_->metadata) {
            metadata_obj[key] = value;
        }
        j["metadata"] = metadata_obj;
    }

    return j.dump(pretty_print ? 2 : -1);
}

} // namespace sum
